---
layout: default
title: MNIST Grid
---

<section class="section">
  <h2>MNIST Drawing Grid</h2>
  <p>Click or tap and drag to draw. Use Clear to reset.</p>

  <div class="mnist-flex">
    <div class="mnist-wrapper">
      <div id="mnist-grid" class="mnist-grid" role="img" aria-label="28 by 28 drawing grid"></div>
    </div>
    <aside class="mnist-panel">
      <div class="mnist-panel-row">
        <div class="mnist-panel-label">Prediction</div>
        <div id="mnist-result" class="mnist-digit">–</div>
      </div>
      <div class="mnist-panel-row small">
        <div class="mnist-panel-label">Confidence</div>
        <div id="mnist-conf" class="mnist-conf">–</div>
      </div>
      <div class="mnist-panel-status" id="mnist-status"></div>
      <div class="mnist-viz">
        <div class="viz-layer">
          <div class="viz-title">Hidden 1</div>
          <div class="viz-nodes" id="viz-h1"></div>
        </div>
        <div class="viz-layer">
          <div class="viz-title">Hidden 2</div>
          <div class="viz-nodes" id="viz-h2"></div>
        </div>
        <div class="viz-layer">
          <div class="viz-title">Output</div>
          <div class="viz-nodes" id="viz-out"></div>
        </div>
      </div>
    </aside>
  </div>

  <p style="margin-top:12px;">
    <button id="mnist-clear">Clear</button>
  </p>
</section>

<style>
  .mnist-flex { display: flex; gap: 16px; align-items: flex-start; }
  .mnist-wrapper { display: flex; justify-content: center; }
  .mnist-grid {
    --cell-size: 16px;
    display: grid;
    grid-template-columns: repeat(28, var(--cell-size));
    grid-template-rows: repeat(28, var(--cell-size));
    gap: 1px;
    background: #333;
    padding: 6px;
    border-radius: 10px;
    touch-action: none; /* better pointer handling on touch */
    user-select: none;
    -webkit-user-select: none;
    cursor: crosshair;
  }
  .mnist-cell { width: var(--cell-size); height: var(--cell-size); background: #000; user-select: none; -webkit-user-select: none; touch-action: none; }
  .mnist-cell.white { background: #fff; }

  .mnist-panel { min-width: 180px; padding: 12px; border: 1px solid var(--border); border-radius: var(--radius); background: var(--surface); box-shadow: var(--shadow); }
  .mnist-panel-row { display: flex; align-items: baseline; justify-content: space-between; gap: 10px; margin-bottom: 8px; }
  .mnist-panel-row.small { font-size: 0.95rem; color: var(--muted); }
  .mnist-panel-label { color: var(--muted); }
  .mnist-digit { font-size: 48px; font-weight: 800; line-height: 1; }
  .mnist-conf { font-variant-numeric: tabular-nums; }

  /* NN visualizer */
  .mnist-viz { margin-top: 10px; display: grid; gap: 10px; }
  .viz-layer { border-top: 1px dashed var(--border); padding-top: 8px; }
  .viz-title { font-size: 0.85rem; color: var(--muted); margin-bottom: 6px; }
  .viz-nodes { display: flex; flex-wrap: wrap; gap: 6px; }
  .viz-node { width: 18px; height: 18px; border-radius: 50%; background: rgba(255,255,255,0.08); border: 1px solid var(--border); box-shadow: var(--shadow); transition: background-color 80ms linear, outline-color 80ms linear; }
  .viz-node.active { outline: 2px solid var(--accent); outline-offset: 1px; }

  @media (max-width: 520px) {
    .mnist-grid { --cell-size: 10px; }
    .mnist-flex { flex-direction: column; }
    .mnist-panel { width: 100%; }
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
<script>
  let model;
  let activationModel;
  async function loadModel() {
    try {
      const statusEl = document.getElementById('mnist-status');
      statusEl.textContent = 'Loading model…';
      model = await tf.loadLayersModel("model_web/model.json");
      statusEl.textContent = 'Model ready';
      console.log("Model loaded!");
      // Construct activation model for hidden layers and logits
      try {
        const layers = model.layers || [];
        let denseLayers = layers.filter(l => typeof l.getClassName === 'function' && l.getClassName() === 'Dense');
        let h1 = denseLayers[0];
        let h2 = denseLayers[1];
        // Fallback by units if needed
        if (!h1 || !h2) {
          h1 = null; h2 = null;
          for (const l of layers) {
            if (l.units === 16 && !h1) { h1 = l; continue; }
            if (l.units === 16 && !h2) { h2 = l; continue; }
          }
        }
        const out = model.outputs[0];
        if (h1 && h2 && out) {
          activationModel = tf.model({ inputs: model.inputs, outputs: [h1.output, h2.output, out] });
        } else {
          activationModel = null;
          console.warn('Could not find expected Dense layers for activations.');
        }
      } catch (e) {
        console.warn('Activation model unavailable:', e);
      }
    } catch (e) {
      console.error('Failed to load model', e);
      const statusEl = document.getElementById('mnist-status');
      statusEl.textContent = 'Model failed to load';
    }
  }

  // Prediction is done inline in the click handler using tf.tidy
</script>
<script>
  (function () {
    const size = 28;
    const gridEl = document.getElementById('mnist-grid');
    const clearBtn = document.getElementById('mnist-clear');
    const resultEl = document.getElementById('mnist-result');
    const confEl = document.getElementById('mnist-conf');
    const cells = gridEl.children;

    // Pixel intensity buffer (0..1)
    const pix = new Float32Array(size * size);

    // Build 28x28 cells
    const frag = document.createDocumentFragment();
    for (let i = 0; i < size * size; i++) {
      const cell = document.createElement('div');
      cell.className = 'mnist-cell';
      cell.dataset.i = i;
      frag.appendChild(cell);
    }
    gridEl.appendChild(frag);

    let drawing = false;

    // Geometry helpers for pointer-based brush
    const styles = getComputedStyle(gridEl);
    function parsePx(v) { return v ? parseFloat(v.toString()) || 0 : 0; }
    let gap = parsePx(styles.gap || styles.columnGap);
    let padL = parsePx(styles.paddingLeft);
    let padT = parsePx(styles.paddingTop);
    let cellSize = cells[0].offsetWidth;
    let pitch = cellSize + gap;
    function recalcGeom() {
      const s = getComputedStyle(gridEl);
      gap = parsePx(s.gap || s.columnGap);
      padL = parsePx(s.paddingLeft);
      padT = parsePx(s.paddingTop);
      cellSize = cells[0].offsetWidth;
      pitch = cellSize + gap;
    }
    window.addEventListener('resize', recalcGeom);

    function setPix(idx, target) {
      if (idx < 0 || idx >= pix.length) return;
      const v = Math.max(pix[idx], target);
      if (v !== pix[idx]) {
        pix[idx] = Math.max(0, Math.min(1, v));
        const intensity = Math.round(pix[idx] * 255); // 0 = black, 255 = white
        cells[idx].style.backgroundColor = `rgb(${intensity}, ${intensity}, ${intensity})`;

      }
    }

    // Paint at pointer location: center 0.95, within 0.25 of edge -> neighbor 0.2
    function paintAt(clientX, clientY) {
      const rect = gridEl.getBoundingClientRect();
      const x = clientX - rect.left - padL;
      const y = clientY - rect.top - padT;
      const j = Math.floor(x / pitch);
      const i = Math.floor(y / pitch);
      if (i < 0 || j < 0 || i >= size || j >= size) return;

      const baseIdx = i * size + j;
      setPix(baseIdx, 1);

      const xInPitch = x - j * pitch;
      const yInPitch = y - i * pitch;
      const rx = Math.max(0, Math.min(1, xInPitch / Math.max(1, cellSize)));
      const ry = Math.max(0, Math.min(1, yInPitch / Math.max(1, cellSize)));
      const th = 0.25;
      if (rx < th && j - 1 >= 0) setPix(i * size + (j - 1), 0.2);
      if (rx > 1 - th && j + 1 < size) setPix(i * size + (j + 1), 0.2);
      if (ry < th && i - 1 >= 0) setPix((i - 1) * size + j, 0.2);
      if (ry > 1 - th && i + 1 < size) setPix((i + 1) * size + j, 0.2);
      if (rx < th && ry < th && i - 1 >= 0 && j - 1 >= 0) setPix((i - 1) * size + (j - 1), 0.2);
      if (rx < th && ry > 1 - th && i + 1 < size && j - 1 >= 0) setPix((i + 1) * size + (j - 1), 0.2);
      if (rx > 1 - th && ry < th && i - 1 >= 0 && j + 1 < size) setPix((i - 1) * size + (j + 1), 0.2);
      if (rx > 1 - th && ry > 1 - th && i + 1 < size && j + 1 < size) setPix((i + 1) * size + (j + 1), 0.2);
    }

    gridEl.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      drawing = true;
      paintAt(e.clientX, e.clientY);
      try { gridEl.setPointerCapture(e.pointerId); } catch (_) {}
      schedulePredict();
    });

    gridEl.addEventListener('pointermove', (e) => {
      if (!drawing) return;
      e.preventDefault();
      paintAt(e.clientX, e.clientY);
      schedulePredict();
    });

    const stop = (e) => {
      drawing = false;
      try { gridEl.releasePointerCapture(e.pointerId); } catch (_) {}
      schedulePredict();
    };
    gridEl.addEventListener('pointerup', stop);
    gridEl.addEventListener('pointercancel', stop);
    gridEl.addEventListener('pointerleave', stop);
    gridEl.addEventListener('dragstart', (e) => e.preventDefault());

    clearBtn.addEventListener('click', () => {
      for (let i = 0; i < pix.length; i++) {
        pix[i] = 0;
        cells[i].style.backgroundColor = '';
      }
      resultEl.textContent = '–';
      confEl.textContent = '–';
      schedulePredict();
    });

    function gridToTensor() {
      // Provide batch dimension [1, 784]
      return tf.tensor2d([pix], [1, size * size]);
    }

    let rafScheduled = false;
    function schedulePredict() {
      if (rafScheduled) return;
      rafScheduled = true;
      requestAnimationFrame(runPredictionFromGrid);
    }

    async function runPredictionFromGrid() {
      rafScheduled = false;
      if (!window.tf || !model) return;
      await tf.ready();

      const x = gridToTensor();
      const out = tf.tidy(() => {
        let h1Vals = null, h2Vals = null, probsVals = null, pred = null, topProb = null;
        if (activationModel) {
          const [h1T, h2T, logitsT] = activationModel.predict(x);
          const probsT = tf.softmax(logitsT);
          pred = probsT.argMax(1).dataSync()[0];
          topProb = probsT.max(1).dataSync()[0];
          h1Vals = Array.from(h1T.dataSync());
          h2Vals = Array.from(h2T.dataSync());
          probsVals = Array.from(probsT.dataSync());
        } else {
          const logits = model.predict(x);
          const probs = tf.softmax(logits);
          pred = probs.argMax(1).dataSync()[0];
          topProb = probs.max(1).dataSync()[0];
          probsVals = Array.from(probs.dataSync());
        }
        return { pred, topProb, h1Vals, h2Vals, probsVals };
      });
      x.dispose();

      resultEl.textContent = String(out.pred);
      confEl.textContent = `${(out.topProb * 100).toFixed(1)}%`;

      // Update NN visualization
      if (!vizBuilt) buildViz();
      if (out.h1Vals) updateLayer(vizH1Nodes, out.h1Vals);
      if (out.h2Vals) updateLayer(vizH2Nodes, out.h2Vals);
      if (out.probsVals) updateLayer(vizOutNodes, out.probsVals, true, out.pred);
    }

    // Viz helpers
    let vizBuilt = false;
    let vizH1Nodes = [], vizH2Nodes = [], vizOutNodes = [];
    function buildViz() {
      if (vizBuilt) return;
      const h1El = document.getElementById('viz-h1');
      const h2El = document.getElementById('viz-h2');
      const outEl = document.getElementById('viz-out');
      vizH1Nodes = createNodes(h1El, 16);
      vizH2Nodes = createNodes(h2El, 16);
      vizOutNodes = createNodes(outEl, 10);
      vizBuilt = true;
    }

    function createNodes(container, count) {
      const arr = [];
      for (let i = 0; i < count; i++) {
        const d = document.createElement('div');
        d.className = 'viz-node';
        container.appendChild(d);
        arr.push(d);
      }
      return arr;
    }

    function updateLayer(nodes, values, isProb = false, activeIndex = -1) {
      const maxVal = isProb ? 1 : Math.max(1e-6, Math.max(...values));
      for (let i = 0; i < nodes.length && i < values.length; i++) {
        const v = values[i] / maxVal; // normalize 0..1
        nodes[i].style.backgroundColor = `rgba(255,255,255,${Math.max(0, Math.min(1, v))})`;
        if (isProb) {
          if (i === activeIndex) nodes[i].classList.add('active');
          else nodes[i].classList.remove('active');
        }
      }
    }

    // Kick off model load
    loadModel().then(() => { buildViz(); schedulePredict(); });
  })();
</script>
